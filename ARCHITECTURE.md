# Архитектура проекта Bookmarks CLI

## Обзор

Проект реорганизован с применением принципов чистой архитектуры (Clean Architecture) и разделения ответственности (Separation of Concerns). Это делает код более поддерживаемым, тестируемым и расширяемым.

## Структура проекта

```
bookmarks-cli/
├── cmd/
│   └── bookmarks-cli/      # Точка входа приложения
│       └── main.go
├── internal/               # Внутренние пакеты (не экспортируются)
│   ├── models/            # Доменные модели
│   │   └── bookmark.go
│   ├── repository/        # Слой доступа к данным
│   │   ├── repository.go  # Интерфейсы
│   │   └── sqlite.go      # SQLite реализация
│   ├── service/           # Бизнес-логика
│   │   └── service.go
│   ├── ui/                # Пользовательский интерфейс (TUI)
│   │   └── app.go
│   ├── parser/            # Парсер HTML закладок
│   │   └── parser.go
│   ├── commands/          # CLI команды
│   │   └── import.go
│   └── config/            # Конфигурация
│       └── config.go
├── go.mod
└── README.md
```

## Слои архитектуры

### 1. Models (Доменные модели)
**Пакет:** `internal/models`

Содержит базовые структуры данных:
- `Bookmark` - структура закладки
- `Folder` - структура папки

**Принципы:**
- Только данные, без логики
- Независимы от других слоев
- Могут использоваться во всех слоях

### 2. Repository (Слой доступа к данным)
**Пакет:** `internal/repository`

**Интерфейсы:**
- `BookmarkRepository` - операции с закладками
- `FolderRepository` - операции с папками
- `Repository` - объединяет все репозитории

**Реализация:**
- `SQLiteRepository` - SQLite реализация

**Преимущества:**
- Абстракция от конкретной БД
- Легко заменить на другую БД (PostgreSQL, MySQL и т.д.)
- Упрощает тестирование (можно создать mock-реализацию)

### 3. Service (Бизнес-логика)
**Пакет:** `internal/service`

**Сервисы:**
- `BookmarkService` - бизнес-логика для закладок
  - `ListAll()` - получить все закладки
  - `Search(query)` - поиск закладок
  - `Create/Update/Delete` - CRUD операции
- `FolderService` - бизнес-логика для папок

**Принципы:**
- Содержит бизнес-логику (поиск, фильтрация)
- Не зависит от UI или БД напрямую
- Работает через интерфейсы репозиториев

### 4. UI (Пользовательский интерфейс)
**Пакет:** `internal/ui`

**Компоненты:**
- `App` - главное приложение TUI
- Использует `tview` для отрисовки
- Зависит только от сервисов, не от репозиториев

**Принципы:**
- Только отображение и обработка ввода
- Вся логика делегируется сервисам
- Легко заменить на другой UI (веб, GUI)

### 5. Parser (Парсер)
**Пакет:** `internal/parser`

**Функциональность:**
- Парсинг HTML файлов закладок
- Использует сервисы для создания папок и закладок

### 6. Commands (CLI команды)
**Пакет:** `internal/commands`

**Команды:**
- `ImportCommand` - импорт закладок из HTML

**Принципы:**
- Каждая команда - отдельный тип
- Легко добавлять новые команды
- Изолированы от UI

### 7. Config (Конфигурация)
**Пакет:** `internal/config`

**Функциональность:**
- Управление конфигурацией приложения
- Путь к БД по умолчанию: `~/.bookmarks/bookmarks.db`
- Возможность переопределения через флаги

## Потоки данных

### Импорт закладок
```
main.go → ImportCommand → Parser → FolderService → Repository → SQLite
                                    ↓
                              BookmarkService → Repository → SQLite
```

### Запуск TUI
```
main.go → UI.App → BookmarkService → Repository → SQLite
                → FolderService → Repository → SQLite
```

## Преимущества новой архитектуры

### 1. Разделение ответственности
- Каждый пакет имеет четкую ответственность
- Легко понять, где что находится

### 2. Тестируемость
- Можно легко создать mock-репозитории для тестов
- Сервисы тестируются независимо от БД
- UI можно тестировать с mock-сервисами

### 3. Расширяемость
- Легко добавить новую команду (создать файл в `commands/`)
- Легко заменить БД (создать новую реализацию `Repository`)
- Легко добавить новый UI (веб-интерфейс, GUI)

### 4. Поддерживаемость
- Изменения в одном слое не влияют на другие
- Легко найти и исправить баги
- Код более читаемый и понятный

### 5. Dependency Injection
- Зависимости передаются через конструкторы
- Нет глобальных переменных
- Легко управлять зависимостями

## Примеры использования

### Добавление новой команды

```go
// internal/commands/export.go
type ExportCommand struct {
    repo repository.Repository
}

func (c *ExportCommand) Execute(outputPath string) error {
    // Логика экспорта
}
```

### Добавление нового репозитория

```go
// internal/repository/postgres.go
type PostgresRepository struct {
    db *sql.DB
}

func NewPostgresRepository(connStr string) (*PostgresRepository, error) {
    // Реализация
}
```

### Создание mock для тестов

```go
// internal/repository/mock.go
type MockRepository struct {
    bookmarks []models.Bookmark
}

func (m *MockRepository) Bookmarks() BookmarkRepository {
    return &mockBookmarkRepo{bookmarks: m.bookmarks}
}
```

## Миграция со старой архитектуры

Старые файлы (`bookmark.go`, `db.go`, `ui.go`, `parser.go`, `main.go`) можно удалить после проверки работоспособности новой архитектуры.

## Рекомендации по дальнейшему развитию

1. **Добавить тесты:**
   - Unit тесты для сервисов
   - Integration тесты для репозиториев
   - E2E тесты для UI

2. **Добавить валидацию:**
   - Валидация URL в `BookmarkService`
   - Валидация данных в формах

3. **Улучшить обработку ошибок:**
   - Кастомные типы ошибок
   - Логирование ошибок

4. **Добавить конфигурационный файл:**
   - YAML/TOML конфиг
   - Настройки темы, горячих клавиш

5. **Добавить плагины:**
   - Экспорт в различные форматы
   - Синхронизация с облачными сервисами
